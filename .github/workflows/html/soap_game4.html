<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Soap Escape</title>
  <style>
    :root{
      --bg:#0f1220; --panel:#171a2b; --text:#e8ecff; --muted:#9aa3c7;
      --border:#262b49; --grid:#2a315c; --grid2:#3f4678;
    }
    html,body{height:100%; overflow-x:hidden}
    body{
      margin:0; background:radial-gradient(1200px 800px at 70% 10%, #141935 0%, #0f1220 60%);
      color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto;
      display:grid; place-items:center; padding:16px; box-sizing:border-box;
    }
    .wrap{ display:grid; gap:14px; width:min(1200px,100%); grid-template-columns: 1fr; }
    @media (min-width:1024px){ .wrap{ grid-template-columns: minmax(640px, 1fr) 360px; } }
    @media (min-width:1280px){ .wrap{ grid-template-columns: 960px 360px; } }

    .panel{ background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent 60%), var(--panel);
      border:1px solid var(--border); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    .game-panel{ position:relative; padding:14px; display:grid; gap:10px; grid-template-rows:auto 1fr auto; }
    .hud{ display:grid; grid-template-columns:repeat(4,1fr); gap:8px; align-items:center; font-size:14px; color:var(--muted); }
    .hud strong{ color:var(--text) }
    .pending-chip{ justify-self:end; background:#202651; border:1px solid #2d3467; color:#bcd0ff;
      padding:6px 10px; border-radius:999px; font-size:12px; display:inline-flex; gap:6px; align-items:center; }

    canvas{
      width:100%; height:auto; aspect-ratio: 9 / 7; display:block;
      background:linear-gradient(180deg,rgba(255,255,255,.04),transparent 40%), #0e1021;
      border-radius:12px; border:1px solid #23284a; touch-action:none;
    }

    .controls{ display:grid; gap:10px; grid-template-columns:1fr 1fr 1fr; }
    .btn{ font-size:16px; background:#1f2442; color:#e5ecff; border:1px solid #2c3158;
      border-radius:12px; padding:12px 14px; cursor:pointer; user-select:none; transition:transform .05s ease, background .2s ease, border-color .2s ease; }
    .btn:hover{ background:#262c52 } .btn:active{ transform:translateY(1px) scale(.99) }
    .btn.primary{ background:#234a63; border-color:#2d6f87 } .btn.primary:hover{ background:#27607e }
    .btn.success{ background:#204f34; border-color:#2b7f53 }

    .side-panel{ padding:12px; display:grid; gap:12px }
    .section{ background:#12152b; border:1px solid #242a4c; border-radius:12px; padding:12px }
    .section h3{ margin:0 0 8px 0; font-size:15px; color:#cfe5ff }
    .kv{ display:grid; grid-template-columns:110px 1fr; gap:6px; font-size:14px; color:#b7c0e6 }
    .kv b{ color:#eef3ff }
    table{ width:100%; border-collapse:collapse; font-size:13px }
    th,td{ padding:8px 10px; border-bottom:1px solid #242a4c; text-align:left }
    th{ color:#cfe5ff; font-weight:600; background:#151830; position:sticky; top:0 }
    tbody tr:hover{ background:rgba(255,255,255,.03) }
    .tag{ font-size:11px; padding:2px 6px; border-radius:6px; border:1px solid #335b66; color:#bcefff; background:#173740 }
    .tag.fail{ color:#ffc3c3; border-color:#66333a; background:#40171d }
    .hint{ font-size:12px; color:var(--muted); line-height:1.45 }
    .log{ background:#0e1021; border:1px solid #23284a; border-radius:8px; padding:8px;
      max-height: clamp(120px, 24vh, 220px); overflow:auto;
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:12px; color:#cfe5ff; line-height:1.35; white-space:pre-wrap; }

    @media (max-width:600px){
      .hud{ grid-template-columns:1fr 1fr; row-gap:6px }
      .controls{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .btn{ padding:10px 12px; font-size:16px; border-radius:14px }
      .kv{ grid-template-columns:1fr }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel game-panel">
      <div class="hud">
        <div>스테이지: <strong id="stageLabel">1 / 5</strong></div>
        <div>경과: <strong id="timeLabel">0.0s</strong></div>
        <div>창문: <strong id="windowLabel">닫힘 (40s 후 오픈)</strong></div>
        <div class="pending-chip">다음 갈림길: <b id="pendingDir">직진</b></div>
      </div>

      <canvas id="gameCanvas" aria-label="game board" role="img"></canvas>

      <div class="controls">
        <button class="btn" id="btnLeft" title="A / ⟵">◀ 왼쪽 (Left)</button>
        <button class="btn primary" id="btnStart" type="button">▶ 게임 시작</button>
        <button class="btn" id="btnRight" title="D / ⟶">오른쪽 (Right) ▶</button>
      </div>
    </div>

    <aside class="panel side-panel">
      <div class="section">
        <h3>플레이 방법</h3>
        <div class="hint">
          비누는 <b>4×4 타일</b>의 선(격자선) 위만 이동합니다. 매 갈림길에서 왼쪽/오른쪽 회전 <b>예약</b>을 누르면
          <b>다음 갈림길</b>에 마지막 입력이 적용돼요. 창문은 시작 시 랜덤 벽 노드에 생성되어 <b>40초 후</b> 열립니다.
        </div>
      </div>

      <div class="section">
        <h3>현재 설정</h3>
        <div class="kv">
          <div>격자/노드</div><div><b>4×4 타일</b> → 교차점 <b>5×5</b></div>
          <div>비누 속도</div><div><b>2.0 노드/초</b></div>
          <div>조작키</div><div><b>A/⟵</b>=왼쪽, <b>D/⟶</b>=오른쪽</div>
        </div>
      </div>

      <div class="section" id="leaderboardSection">
        <h3>순위표 (로컬)</h3>
        <div style="max-height:260px; overflow:auto; margin-top:8px;">
          <table>
            <thead><tr><th style="width:56px">순위</th><th>이름</th><th>스테이지</th><th>결과</th><th>시간</th><th>날짜</th></tr></thead>
            <tbody id="leaderboardBody"></tbody>
          </table>
        </div>
      </div>

      <div class="section">
        <h3>이벤트 로그</h3>
        <div class="hint">입력/회전/충돌/탈출 시각을 <b>초단위</b>로 기록합니다.</div>
        <pre id="logBox" class="log" aria-live="polite"></pre>
        <button class="btn" id="btnClearLog">로그 비우기</button>
      </div>
    </aside>
  </div>

  <script type="application/json" id="stage-config">
  {
    "windowOpenMs": 40000,
    "graceMs": 5000,
    "speedNodesPerSec": 2.0,
    "stages": [
      { "maxObstacles": 10, "obstacleLifetimeMs": 5000, "obstacleSpawnIntervalMs": 1000 },
      { "maxObstacles": 12, "obstacleLifetimeMs": 6000, "obstacleSpawnIntervalMs": 900 },
      { "maxObstacles": 14, "obstacleLifetimeMs": 7000, "obstacleSpawnIntervalMs": 800 },
      { "maxObstacles": 16, "obstacleLifetimeMs": 8000, "obstacleSpawnIntervalMs": 700 },
      { "maxObstacles": 18, "obstacleLifetimeMs": 9000, "obstacleSpawnIntervalMs": 600 }
    ]
  }
  </script>

  <script>
  // ===== 유틸 =====
  const U = {
    randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; },
    now(){ return performance.now(); },
    fmtTime(ms){ return (ms/1000).toFixed(1)+'s'; },
    fmtDate(ts){ return new Date(ts).toLocaleString(); },
    saveJSON(k,o){ localStorage.setItem(k, JSON.stringify(o)); },
    loadJSON(k,f){ try{ return JSON.parse(localStorage.getItem(k)) ?? f; }catch{ return f; } }
  };

  // ===== 엘리먼트 =====
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const stageLabel = document.getElementById('stageLabel');
  const timeLabel = document.getElementById('timeLabel');
  const windowLabel = document.getElementById('windowLabel');
  const pendingDirEl = document.getElementById('pendingDir');
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnStart = document.getElementById('btnStart');
  const leaderboardBody = document.getElementById('leaderboardBody');
  const logBox = document.getElementById('logBox');
  const btnClearLog = document.getElementById('btnClearLog');

  // ===== 로그 =====
  const LOG=[]; function logEvent(type, detail=''){
    const running = G.running && G.startMs>0;
    const sec = running ? ((U.now()-G.startMs)/1000).toFixed(1)+'s' : '—';
    LOG.unshift(`[${sec}] ${type}${detail?` - ${detail}`:''}`);
    if(LOG.length>200) LOG.pop();
    logBox.textContent = LOG.join('\\n');
  }
  btnClearLog?.addEventListener('click', ()=>{ LOG.length = 0; logBox.textContent=''; });

  // ===== 설정 =====
  const CONFIG = JSON.parse(document.getElementById('stage-config').textContent);
  const WARN_BEFORE_MS = 5000; // 창문 열리기 이전 경고 시간 (ms)

  // ===== 상태 =====
  const DIRS=[{x:1,y:0},{x:0,y:1},{x:-1,y:0},{x:0,y:-1}];
  const BASIN_FALL_MS = 600;   // 세숫대야 떨어지는 연출 시간

  const G={
    gridTiles:4, gridNodes:5,
    margin:40,
    pendingTurn:null, running:false, stageIndex:0,
    startMs:0, elapsedMs:0, lastFrame:0,
    nodeA:{x:0,y:0}, nodeB:{x:1,y:0}, t:0, dir:0,
    window:{x:0,y:0,side:'TOP',openAt:0,opened:false},
    obstacles:[], nextSpawnAt:Infinity, graceUntil:0, result:null,
    warned:false
  };

  // ===== 캔버스 리사이즈 =====
  const ASPECT_W = 9, ASPECT_H = 7;
  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
    const cssWidth = Math.floor(canvas.clientWidth);
    const cssHeight = Math.floor(cssWidth * ASPECT_H / ASPECT_W);
    const needW = Math.round(cssWidth * dpr);
    const needH = Math.round(cssHeight * dpr);
    if (canvas.width !== needW || canvas.height !== needH){
      canvas.width = needW; canvas.height = needH;
    }
    const scale = cssWidth / 900;
    G.margin = Math.max(24, Math.round(40 * scale));
    ctx.setTransform(1,0,0,1,0,0);
  }
  new ResizeObserver(resizeCanvas).observe(canvas);
  window.addEventListener('orientationchange', ()=>setTimeout(resizeCanvas, 50));

  // ===== 좌표계 =====
  function nodeToXY(n){
    const usableW = canvas.width - G.margin*2;
    const usableH = canvas.height - G.margin*2;
    return {
      x: G.margin + n.x * (usableW/(G.gridNodes-1)),
      y: G.margin + n.y * (usableH/(G.gridNodes-1))
    };
  }
  function soapPos(){
    const a=nodeToXY(G.nodeA), b=nodeToXY(G.nodeB);
    return { x:a.x + (b.x-a.x)*G.t, y:a.y + (b.y-a.y)*G.t };
  }
  function edgeId(a,b){
    const k1=`${a.x},${a.y}`, k2=`${b.x},${b.y}`;
    return (k1<k2)?`${k1}-${k2}`:`${k2}-${k1}`;
  }

  // ===== 입력/회전 =====
  function reserveTurn(dir){ G.pendingTurn=dir; updatePendingLabel(); logEvent('INPUT', dir==='L'?'LEFT':'RIGHT'); }
  function applyPendingTurnAtJunction(){
    if(G.pendingTurn===null){ logEvent('TURN','직진'); return; }
    if(G.pendingTurn==='L'){ G.dir=(G.dir+3)%4; logEvent('TURN','좌회전 적용'); }
    else { G.dir=(G.dir+1)%4; logEvent('TURN','우회전 적용'); }
    G.pendingTurn=null; updatePendingLabel();
  }

  // ===== 이동/충돌 =====
  function stepToNextEdge(){
    const curr=G.nodeB, dirVec=DIRS[G.dir], next={x:curr.x+dirVec.x, y:curr.y+dirVec.y};
    const max = G.gridNodes - 1;
    const goingOutside = (next.x<0||next.x>max||next.y<0||next.y>max);
    if(goingOutside){
      const atWindow = (curr.x===G.window.x && curr.y===G.window.y);
      if(atWindow && G.window.opened){ logEvent('EXIT',`창문 node=(${curr.x},${curr.y})`); endGame('clear'); }
      else { const side=(curr.y===0?'TOP':(curr.y===max?'BOTTOM':(curr.x===0?'LEFT':'RIGHT'))); logEvent('CRASH',`벽 (${side}) node=(${curr.x},${curr.y})`); endGame('fail','벽에 충돌 (창문 닫힘)'); }
      return false;
    }
    G.nodeA=curr; G.nodeB=next; G.t=0;
    // edge-block check removed: only collide on actual contact (see checkBasinCollision())
    return true;
  }

  // ===== 대야 스폰 =====
    function trySpawnObstacle(){
  const st = CONFIG.stages[G.stageIndex], now = U.now();
  // 만료 제거
  G.obstacles = G.obstacles.filter(o => o.until > now);

  if (now < G.graceUntil || G.obstacles.length >= st.maxObstacles || now < G.nextSpawnAt) return;

  // 가능한 엣지 수집
  const edges = []; const max = G.gridNodes - 1;
  for (let y = 0; y <= max; y++) {
    for (let x = 0; x <= max; x++) {
      if (x < max) edges.push({ a: { x: x, y: y }, b: { x: x + 1, y: y } }); // horizontal
      if (y < max) edges.push({ a: { x: x, y: y }, b: { x: x,     y: y + 1 } }); // vertical
    }
  }

  // 창문 노드 인접 엣지는 제외
  const safeEdges = edges.filter(e =>
    !((e.a.x===G.window.x && e.a.y===G.window.y) || (e.b.x===G.window.x && e.b.y===G.window.y))
  );

  // 현재 이동 중인 엣지는 제외
  const currentId = edgeId(G.nodeA, G.nodeB);
  const pool = safeEdges.filter(e => edgeId(e.a, e.b) !== currentId);
  if (!pool.length) { G.nextSpawnAt = now + 200; return; }

  const pick = pool[U.randInt(0, pool.length - 1)];
  const id = edgeId(pick.a, pick.b);
  if (G.obstacles.some(o => o.id === id && o.until > now)) { G.nextSpawnAt = now + 150; return; }

  // 중심 좌표(화면 좌표계) 저장
  const a = nodeToXY(pick.a), b = nodeToXY(pick.b);
  const center = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };

  const WARNING_MS = 2000;
  const dropAt = now + WARNING_MS;
  const landAt = dropAt + BASIN_FALL_MS;

  G.obstacles.push({
    id: id,
    a: pick.a, b: pick.b,
    center: center,
    spawn: now,
    warnFrom: now,
    dropAt: dropAt,
    landAt: landAt,
    until: now + st.obstacleLifetimeMs + WARNING_MS + BASIN_FALL_MS,
    state: 'warning'
  });

  G.nextSpawnAt = now + st.obstacleSpawnIntervalMs;
}
function drawObstacles(){
  const now = U.now();
  // purge expired
  G.obstacles = G.obstacles.filter(o => o.until > now);

  const usableH = canvas.height - G.margin*2;
  const stepY = usableH/(G.gridNodes-1);
  const radius = stepY * 0.18; // smaller so it doesn't block other lanes

  for (const o of G.obstacles){
    // advance state
    if (o.state === 'warning' && now >= o.dropAt) o.state = 'falling';
    if (o.state === 'falling' && now >= o.landAt) o.state = 'landed';

    // warning indicator
    if (o.state === 'warning'){
      const t = Math.max(0, Math.min(1, (now - o.warnFrom) / 2000));
      const pulse = 1 + 0.2 * Math.sin(t * 10);
      ctx.save();
      ctx.translate(o.center.x, o.center.y);
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#ff4d4d';
      ctx.beginPath();
      ctx.arc(0, 0, radius * 1.2 * pulse, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#ff4d4d';
      ctx.beginPath();
      ctx.arc(0, 0, radius * 0.9, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      continue;
    }

    let offsetY = 0;
    if (o.state === 'falling'){
      const t = Math.min(1, (now - o.dropAt) / BASIN_FALL_MS);
      const fallDist = stepY * 0.8;
      offsetY = -fallDist * (1 - t);
    }

    ctx.save();
    ctx.translate(o.center.x, o.center.y + offsetY);

    // shadow
    const shadowY = 6 + Math.max(0, -offsetY*0.08);
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.beginPath();
    ctx.ellipse(6, shadowY, radius*0.75, radius*0.40, 0, 0, Math.PI*2);
    ctx.fillStyle = '#000';
    ctx.fill();
    ctx.restore();

    // basin body
    const rim = Math.max(2, radius*0.16);
    ctx.beginPath(); ctx.arc(0,0, radius, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff'; ctx.fill();
    ctx.lineWidth = rim; ctx.strokeStyle = '#dfe6ff'; ctx.stroke();

    // inner ellipse
    ctx.beginPath(); ctx.ellipse(0, 0, radius*0.8, radius*0.5, 0, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(180,200,255,0.8)';
    ctx.lineWidth = 1.2; ctx.stroke();

    ctx.restore();
  }
}
function drawSoap(){
    const pos=soapPos();
    ctx.save();
    const angle=[0,Math.PI/2,Math.PI,-Math.PI/2][G.dir];
    ctx.translate(pos.x,pos.y); ctx.rotate(angle);

    // 그림자
    ctx.globalAlpha=0.3; circle(10,10,9,'#000'); ctx.globalAlpha=1;

    // 비누: 직사각형
    const w=24, h=14;
    ctx.fillStyle='#9ee7ff'; ctx.strokeStyle='#62c7e8';
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.rect(-w/2, -h/2, w, h);
    ctx.fill(); ctx.stroke();

    // 하이라이트
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.fillRect(-w*0.25, -h*0.25, w*0.2, h*0.18);

    // 창문 열림 5초 전 말풍선(항상 수평)
    (function(){
      const now = U.now();
      if(G.running && now >= G.window.openAt - WARN_BEFORE_MS && now < G.window.openAt){
        const label = '열린다!';
        ctx.save();
        ctx.rotate(-angle);
        const n = (G.dir % 2 === 0) ? {x:0, y:-1} : {x:1, y:0};
        const offX = n.x * 18, offY = n.y * 18;
        ctx.translate(offX, offY);

        const t = (now % 1000) / 1000;
        const pulse = 0.9 + 0.1*Math.sin(t*2*Math.PI);

        ctx.font = 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const padX = 8, h = 20;
        const wRect = ctx.measureText(label).width + padX*2;

        ctx.globalAlpha = 0.92;
        ctx.fillStyle = 'rgba(32, 38, 81, 0.92)';
        (function roundRect(x,y,w,h,r){
          const rr = Math.min(r, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x+rr, y);
          ctx.lineTo(x+w-rr, y);
          ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
          ctx.lineTo(x+w, y+h-rr);
          ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
          ctx.lineTo(x+rr, y+h);
          ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
          ctx.lineTo(x, y+rr);
          ctx.quadraticCurveTo(x, y, x+rr, y);
          ctx.closePath();
        })(-wRect/2, -h-10, wRect, h, 8);
        ctx.fill();

        ctx.lineWidth = 2 * pulse;
        ctx.strokeStyle = 'rgba(77, 255, 136, 0.95)';
        (function(){
          const x=-wRect/2, y=-h-10, w=wRect, r=8;
          const rr = Math.min(r, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x+rr, y);
          ctx.lineTo(x+w-rr, y);
          ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
          ctx.lineTo(x+w, y+h-rr);
          ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
          ctx.lineTo(x+rr, y+h);
          ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
          ctx.lineTo(x, y+rr);
          ctx.quadraticCurveTo(x, y, x+rr, y);
          ctx.closePath();
        })();
        ctx.stroke();

        ctx.fillStyle = '#c9ffdf';
        ctx.fillText(label, 0, -h/2-10);

        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(4, -4);
        ctx.lineTo(-4, -4);
        ctx.closePath();
        ctx.fillStyle = 'rgba(32, 38, 81, 0.92)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(77, 255, 136, 0.95)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.restore();
      }
    })();

    ctx.restore();
  }

  // ===== 순위표 =====
  const LEADER_KEY='soap_escape_leaderboard_v1';
  function saveToLeaderboard(rec){
    const list=U.loadJSON(LEADER_KEY,[]);
    list.push(rec);
    list.sort((a,b)=>{
      const ca=a.result==='CLEAR', cb=b.result==='CLEAR';
      if(ca!==cb) return cb-ca;
      if(ca) return a.timeMs - b.timeMs;
      return b.timeMs - a.timeMs;
    });
    U.saveJSON(LEADER_KEY, list.slice(0,100));
  }
  function renderLeaderboard(){
    const list=U.loadJSON(LEADER_KEY,[]);
    leaderboardBody.innerHTML='';
    list.forEach((r,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>${i+1}</td>
        <td>${escapeHtml(r.name)}</td>
        <td>${r.stage}</td>
        <td><span class="tag ${r.result==='CLEAR'?'':'fail'}">${r.result}</span></td>
        <td>${U.fmtTime(r.timeMs)}</td>
        <td>${U.fmtDate(r.ts)}</td>`;
      leaderboardBody.appendChild(tr);
    });
  }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])); }
[m])); }

  // ===== 입력 바인딩 =====
  btnLeft.addEventListener('click', ()=>reserveTurn('L'));
  btnRight.addEventListener('click', ()=>reserveTurn('R'));
  btnStart.addEventListener('click', ()=>{ if(G.running) endGame('fail','중지 버튼으로 게임을 종료했습니다.'); else startGame(); });
  window.addEventListener('keydown', (e)=>{
    if(e.key==='a'||e.key==='A'||e.key==='ArrowLeft') { e.preventDefault(); reserveTurn('L'); }
    else if(e.key==='d'||e.key==='D'||e.key==='ArrowRight') { e.preventDefault(); reserveTurn('R'); }
    else if(e.key===' '){ e.preventDefault(); if(!G.running) startGame(); }
  });

  // ===== 시작 위치 & 창문 =====
  function pickRandomStart(){
    const max=G.gridNodes-1;
    while(true){
      const x=U.randInt(0,max), y=U.randInt(0,max); let dir=U.randInt(0,3);
      if((x===0&&dir===2)||(x===max&&dir===0)||(y===0&&dir===3)||(y===max&&dir===1)) dir=(dir+1)%4;
      const a={x:x,y:y}, d=DIRS[dir], b={x:x+d.x, y:y+d.y};
      if(b.x>=0 && b.x<=max && b.y>=0 && b.y<=max){ G.nodeA=a; G.nodeB=b; G.dir=dir; G.t=0; return; }
    }
  }
  function pickRandomWindow(){
    const choices=[]; const max=G.gridNodes-1;
    for(let i=1;i<=max-1;i++){
      choices.push({x:i,y:0,side:'TOP'},{x:i,y:max,side:'BOTTOM'},{x:0,y:i,side:'LEFT'},{x:max,y:i,side:'RIGHT'});
    }
    const w=choices[U.randInt(0,choices.length-1)];
    G.window = { x:w.x, y:w.y, side:w.side, openAt: G.startMs + CONFIG.windowOpenMs, opened:false };
  }

  // ===== 초기화 =====
  function init(){
    try {
      resizeCanvas();
      renderLeaderboard();
      draw(); updateHUD();
      btnStart.addEventListener('contextmenu', e=>{
        e.preventDefault();
        G.stageIndex = (G.stageIndex+1) % CONFIG.stages.length;
        stageLabel.textContent = `${G.stageIndex+1} / ${CONFIG.stages.length}`;
      });
    } catch (e) {
      console.error('Init error:', e);
    }
  }
  window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>