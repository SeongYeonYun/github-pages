<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Soap Escape — 4x4 타일 탈출 게임 (Responsive)</title>
  <style>
    :root{
      --bg:#0f1220; --panel:#171a2b; --text:#e8ecff; --muted:#9aa3c7;
      --border:#262b49; --grid:#2a315c; --grid2:#3f4678;
    }
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(1200px 800px at 70% 10%, #141935 0%, #0f1220 60%);
      color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto;
      display:grid; place-items:center; padding:16px; box-sizing:border-box;
    }
    .wrap{
      display:grid; gap:14px; width:min(1200px,100%);
      grid-template-columns: 1fr;
    }
    /* >= 1024px 에서 2열 */
    @media (min-width:1024px){
      .wrap{ grid-template-columns: minmax(640px, 1fr) 360px; }
    }
    /* >= 1280px 에서 게임판 더 넉넉하게 */
    @media (min-width:1280px){
      .wrap{ grid-template-columns: 960px 360px; }
    }

    .panel{
      background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent 60%), var(--panel);
      border:1px solid var(--border); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .game-panel{ position:relative; padding:14px; display:grid; gap:10px; grid-template-rows:auto 1fr auto; }
    .hud{
      display:grid; grid-template-columns:repeat(4,1fr); gap:8px; align-items:center;
      font-size:14px; color:var(--muted);
    }
    .hud strong{ color:var(--text) }
    .pending-chip{
      justify-self:end; background:#202651; border:1px solid #2d3467; color:#bcd0ff;
      padding:6px 10px; border-radius:999px; font-size:12px; display:inline-flex; gap:6px; align-items:center;
    }

    canvas{
      width:100%;
      height:auto;
      aspect-ratio: 9 / 7; /* 내부는 JS에서 DPR에 맞춰 동적으로 조정 */
      display:block;
      background:linear-gradient(180deg,rgba(255,255,255,.04),transparent 40%), #0e1021;
      border-radius:12px; border:1px solid #23284a;
      touch-action:none;
    }

    .controls{
      display:grid; gap:10px; grid-template-columns:1fr 1fr 1fr;
    }
    .btn{
      font-size:16px; background:#1f2442; color:#e5ecff; border:1px solid #2c3158;
      border-radius:12px; padding:12px 14px; cursor:pointer; user-select:none; transition:transform .05s ease, background .2s ease, border-color .2s ease;
    }
    .btn:hover{ background:#262c52 } .btn:active{ transform:translateY(1px) scale(.99) }
    .btn.primary{ background:#234a63; border-color:#2d6f87 } .btn.primary:hover{ background:#27607e }
    .btn.success{ background:#204f34; border-color:#2b7f53 }

    .side-panel{ padding:12px; display:grid; gap:12px }
    .section{ background:#12152b; border:1px solid #242a4c; border-radius:12px; padding:12px }
    .section h3{ margin:0 0 8px 0; font-size:15px; color:#cfe5ff }
    .kv{ display:grid; grid-template-columns:110px 1fr; gap:6px; font-size:14px; color:#b7c0e6 }
    .kv b{ color:#eef3ff }

    table{ width:100%; border-collapse:collapse; font-size:13px }
    th,td{ padding:8px 10px; border-bottom:1px solid #242a4c; text-align:left }
    th{ color:#cfe5ff; font-weight:600; background:#151830; position:sticky; top:0 }
    tbody tr:hover{ background:rgba(255,255,255,.03) }
    .tag{ font-size:11px; padding:2px 6px; border-radius:6px; border:1px solid #335b66; color:#bcefff; background:#173740 }
    .tag.fail{ color:#ffc3c3; border-color:#66333a; background:#40171d }

    .hint{ font-size:12px; color:var(--muted); line-height:1.45 }
    .log{
      background:#0e1021; border:1px solid #23284a; border-radius:8px; padding:8px;
      max-height: clamp(120px, 24vh, 220px); overflow:auto;
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:12px; color:#cfe5ff; line-height:1.35; white-space:pre-wrap;
    }

    /* 모바일 최적화 */
    @media (max-width:600px){
      .hud{ grid-template-columns:1fr 1fr; row-gap:6px }
      .controls{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .btn{ padding:10px 12px; font-size:16px; border-radius:14px }
      .kv{ grid-template-columns:1fr }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel game-panel">
      <div class="hud">
        <div>스테이지: <strong id="stageLabel">1 / 5</strong></div>
        <div>경과: <strong id="timeLabel">0.0s</strong></div>
        <div>창문: <strong id="windowLabel">닫힘 (40s 후 오픈)</strong></div>
        <div class="pending-chip">다음 갈림길: <b id="pendingDir">직진</b></div>
      </div>

      <canvas id="gameCanvas" aria-label="game board" role="img"></canvas>

      <div class="controls">
        <button class="btn" id="btnLeft" title="A / ⟵">◀ 왼쪽 (Left)</button>
        <button class="btn primary" id="btnStart">▶ 게임 시작</button>
        <button class="btn" id="btnRight" title="D / ⟶">오른쪽 (Right) ▶</button>
      </div>
    </div>

    <aside class="panel side-panel">
      <div class="section">
        <h3>플레이 방법</h3>
        <div class="hint">
          비누는 <b>4×4 타일</b>의 선(격자선) 위만 이동합니다. 매 갈림길에서 왼쪽/오른쪽 회전 <b>예약</b>을 누르면
          <b>다음 갈림길</b>에 마지막 입력이 적용돼요. 창문은 시작 시 랜덤 벽 노드에 생성되어 <b>40초 후</b> 열립니다.
        </div>
      </div>

      <div class="section">
        <h3>현재 설정</h3>
        <div class="kv">
          <div>격자/노드</div><div><b>4×4 타일</b> → 교차점 <b>5×5</b></div>
          <div>비누 속도</div><div><b>2.0 노드/초</b></div>
          <div>조작키</div><div><b>A/⟵</b>=왼쪽, <b>D/⟶</b>=오른쪽</div>
        </div>
      </div>

      <div class="section" id="leaderboardSection">
        <h3>순위표 (로컬)</h3>
        <div style="max-height:260px; overflow:auto; margin-top:8px;">
          <table>
            <thead><tr><th style="width:56px">순위</th><th>이름</th><th>스테이지</th><th>결과</th><th>시간</th><th>날짜</th></tr></thead>
            <tbody id="leaderboardBody"></tbody>
          </table>
        </div>
      </div>

      <div class="section">
        <h3>이벤트 로그</h3>
        <div class="hint">입력/회전/충돌/탈출 시각을 <b>초단위</b>로 기록합니다.</div>
        <pre id="logBox" class="log" aria-live="polite"></pre>
        <button class="btn" id="btnClearLog">로그 비우기</button>
      </div>
    </aside>
  </div>

  <script type="application/json" id="stage-config">
  {
    "windowOpenMs": 40000,
    "graceMs": 5000,
    "speedNodesPerSec": 2.0,
    "stages": [
      { "maxObstacles": 10, "obstacleLifetimeMs": 5000, "obstacleSpawnIntervalMs": 1000 },
      { "maxObstacles": 12, "obstacleLifetimeMs": 6000, "obstacleSpawnIntervalMs": 900  },
      { "maxObstacles": 14, "obstacleLifetimeMs": 7000, "obstacleSpawnIntervalMs": 800  },
      { "maxObstacles": 16, "obstacleLifetimeMs": 8000, "obstacleSpawnIntervalMs": 700  },
      { "maxObstacles": 18, "obstacleLifetimeMs": 9000, "obstacleSpawnIntervalMs": 600  }
    ]
  }
  </script>

  <script>
  // ===== 유틸 =====
  const U = {
    randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; },
    now(){ return performance.now(); },
    fmtTime(ms){ return (ms/1000).toFixed(1)+'s'; },
    fmtDate(ts){ return new Date(ts).toLocaleString(); },
    saveJSON(k,o){ localStorage.setItem(k, JSON.stringify(o)); },
    loadJSON(k,f){ try{ return JSON.parse(localStorage.getItem(k)) ?? f; }catch{ return f; } }
  };

  // ===== 전역 상태 =====
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const stageLabel = document.getElementById('stageLabel');
  const timeLabel = document.getElementById('timeLabel');
  const windowLabel = document.getElementById('windowLabel');
  const pendingDirEl = document.getElementById('pendingDir');
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnStart = document.getElementById('btnStart');
  const leaderboardBody = document.getElementById('leaderboardBody');
  const logBox = document.getElementById('logBox');
  const btnClearLog = document.getElementById('btnClearLog');

  const LOG=[]; function logEvent(type, detail=''){
    const running = G.running && G.startMs>0;
    const sec = running ? ((U.now()-G.startMs)/1000).toFixed(1)+'s' : '—';
    LOG.unshift(`[${sec}] ${type}${detail?` - ${detail}`:''}`);
    if(LOG.length>200) LOG.pop();
    logBox.textContent = LOG.join('\\n');
  }
  btnClearLog?.addEventListener('click', ()=>{ LOG.length = 0; logBox.textContent=''; });

  const CONFIG = JSON.parse(document.getElementById('stage-config').textContent);

  const WARN_BEFORE_MS = 5000; // 창문 열리기 이전 경고 시간 (ms)

  // 게임 상태
  const DIRS=[{x:1,y:0},{x:0,y:1},{x:-1,y:0},{x:0,y:-1}];
  const G={
    gridTiles:4, gridNodes:5,
    margin:40,
    pendingTurn:null, running:false, stageIndex:0,
    startMs:0, elapsedMs:0, lastFrame:0,
    nodeA:{x:0,y:0}, nodeB:{x:1,y:0}, t:0, dir:0,
    window:{x:0,y:0,side:'TOP',openAt:0,opened:false},
    obstacles:[], nextSpawnAt:Infinity, graceUntil:0, result:null, warned:false
  };

  // ===== 반응형 캔버스 =====
  const ASPECT_W = 9, ASPECT_H = 7;
  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
    const cssWidth = Math.floor(canvas.clientWidth);
    const cssHeight = Math.floor(cssWidth * ASPECT_H / ASPECT_W);
    const needW = Math.round(cssWidth * dpr);
    const needH = Math.round(cssHeight * dpr);
    if (canvas.width !== needW || canvas.height !== needH){
      canvas.width = needW; canvas.height = needH;
    }
    const scale = cssWidth / 900;
    G.margin = Math.max(24, Math.round(40 * scale));
    ctx.setTransform(1,0,0,1,0,0);
  }
  new ResizeObserver(resizeCanvas).observe(canvas);
  window.addEventListener('orientationchange', ()=>setTimeout(resizeCanvas, 50));

  // ===== 좌표/도형 =====
  function nodeToXY(n){
    const usableW = canvas.width - G.margin*2;
    const usableH = canvas.height - G.margin*2;
    return {
      x: G.margin + n.x * (usableW/(G.gridNodes-1)),
      y: G.margin + n.y * (usableH/(G.gridNodes-1))
    };
  }
  function soapPos(){
    const a=nodeToXY(G.nodeA), b=nodeToXY(G.nodeB);
    return { x:a.x + (b.x-a.x)*G.t, y:a.y + (b.y-a.y)*G.t };
  }
  function edgeId(a,b){
    const k1=`${a.x},${a.y}`, k2=`${b.x},${b.y}`;
    return (k1<k2)?`${k1}-${k2}`:`${k2}-${k1}`;
  }

  // ===== 입력/회전 =====
  function reserveTurn(dir){ G.pendingTurn=dir; updatePendingLabel(); logEvent('INPUT', dir==='L'?'LEFT':'RIGHT'); }
  function applyPendingTurnAtJunction(){
    if(G.pendingTurn===null){ logEvent('TURN','직진'); return; }
    if(G.pendingTurn==='L'){ G.dir=(G.dir+3)%4; logEvent('TURN','좌회전 적용'); }
    else { G.dir=(G.dir+1)%4; logEvent('TURN','우회전 적용'); }
    G.pendingTurn=null; updatePendingLabel();
  }

  // ===== 이동/충돌 =====
  function stepToNextEdge(){
    const curr=G.nodeB, dirVec=DIRS[G.dir], next={x:curr.x+dirVec.x, y:curr.y+dirVec.y};
    const max = G.gridNodes - 1;
    const goingOutside = (next.x<0||next.x>max||next.y<0||next.y>max);
    if(goingOutside){
      const atWindow = (curr.x===G.window.x && curr.y===G.window.y);
      if(atWindow && G.window.opened){ logEvent('EXIT',`창문 node=(${curr.x},${curr.y})`); endGame('clear'); }
      else { const side=(curr.y===0?'TOP':(curr.y===max?'BOTTOM':(curr.x===0?'LEFT':'RIGHT'))); logEvent('CRASH',`벽 (${side}) node=(${curr.x},${curr.y})`); endGame('fail','벽에 충돌 (창문 닫힘)'); }
      return false;
    }
    G.nodeA=curr; G.nodeB=next; G.t=0;
    const eid=edgeId(G.nodeA,G.nodeB);
    const hit = G.obstacles.some(o=>o.id===eid && o.until>U.now());
    if(hit){ logEvent('CRASH',`대야 충돌 edge=${eid}`); endGame('fail','대야(장애물) 충돌'); return false; }
    return true;
  }

  // ===== 대야 스폰 =====
  function trySpawnObstacle(){
    const st=CONFIG.stages[G.stageIndex], now=U.now();
    G.obstacles = G.obstacles.filter(o=>o.until>now);
    if(now<G.graceUntil || G.obstacles.length>=st.maxObstacles || now<G.nextSpawnAt) return;

    const edges=[]; const max=G.gridNodes-1;
    for(let y=0; y<=max; y++) for(let x=0; x<=max; x++){
      if(x<max) edges.push({a:{x,y}, b:{x:x+1,y}});
      if(y<max) edges.push({a:{x,y}, b:{x, y:y+1}});
    }
    const safeEdges = edges.filter(e =>
      !((e.a.x===G.window.x&&e.a.y===G.window.y) || (e.b.x===G.window.x&&e.b.y===G.window.y))
    );
    const currentId = edgeId(G.nodeA, G.nodeB);
    const pool = safeEdges.filter(e => edgeId(e.a,e.b)!==currentId);
    if(!pool.length){ G.nextSpawnAt = now + 200; return; }

    const pick = pool[U.randInt(0, pool.length-1)];
    const id = edgeId(pick.a, pick.b);
    if(G.obstacles.some(o=>o.id===id)){ G.nextSpawnAt=now+150; return; }

    G.obstacles.push({ id, a:pick.a, b:pick.b, until: now + st.obstacleLifetimeMs });
    G.nextSpawnAt = now + st.obstacleSpawnIntervalMs;
  }

  // ===== HUD/시작/종료 =====
  function updatePendingLabel(){ pendingDirEl.textContent = ({L:'왼쪽', R:'오른쪽'})[G.pendingTurn] ?? '직진'; }
  function startGame(){
    G.running=true; G.result=null;
    G.startMs=U.now(); G.elapsedMs=0; G.lastFrame=G.startMs;
    G.obstacles=[]; G.pendingTurn=null; G.warned=false;
    G.graceUntil = G.startMs + CONFIG.graceMs;
    G.nextSpawnAt = G.graceUntil;
    pickRandomStart(); pickRandomWindow(); updatePendingLabel();
    logEvent('START',`스테이지 ${G.stageIndex+1}`);
    btnStart.textContent='■ 중지'; btnStart.classList.add('success');
    requestAnimationFrame(loop);
  }
  function endGame(result, reason=''){
    if(!G.running) return; G.running=false; G.result=result;
    btnStart.textContent='▶ 게임 시작'; btnStart.classList.remove('success');
    logEvent(result==='clear'?'CLEAR':'FAIL', reason || '');
    G.elapsedMs = U.now() - G.startMs;

    const clear = (result==='clear');
    const msg = `${clear?'클리어!':'실패!'}\\n스테이지 ${G.stageIndex+1} / 경과 ${U.fmtTime(G.elapsedMs)}${reason?`\\n\\n사유: ${reason}`:''}`;
    const name = prompt(msg+"\\n\\n기록 이름 입력(취소시 저장 안 함)", "Player");
    if(name && name.trim()){
      saveToLeaderboard({ name:name.trim(), stage:G.stageIndex+1, result: clear?'CLEAR':'FAIL', timeMs:G.elapsedMs, ts:Date.now() });
      renderLeaderboard();
    }
  }

  // ===== 거품 파티클 (3초 지속, 0.18s 팝) =====
  const BUBBLE_LIFE = 3.0;      // ← 요청: 3초로 증가
  const POP_TIME    = 0.18;
  const EMIT_PER_PX = 0.018;
  const MIN_R=3, MAX_R=10, UP_FLOAT=12, DRIFT=10, FADE=0.25;
  const POOL_SIZE = 700;
  const bubbles = new Array(POOL_SIZE).fill(null).map(()=>({alive:false,x:0,y:0,r:0,vx:0,vy:0,born:0,life:BUBBLE_LIFE,alpha:1,state:0,popT:0}));
  let poolHead = 0;
  let lastEmitPos = null;

  function rand(a,b){ return a + Math.random()*(b-a); }
  function spawnBubble(x,y){
    const b = bubbles[poolHead]; poolHead=(poolHead+1)%POOL_SIZE;
    b.alive=true; b.state=0; b.popT=0;
    b.x=x+(Math.random()*6-3); b.y=y+(Math.random()*6-3);
    b.r=rand(MIN_R,MAX_R);
    b.vx=(Math.random()*2-1)*DRIFT;
    b.vy=-UP_FLOAT - Math.random()*UP_FLOAT*0.6;
    b.born=U.now()/1000;
    b.life=BUBBLE_LIFE * rand(0.9,1.1);
    b.alpha=0.9;
  }
  function emitByDistance(dist, x, y){
    let expected = dist * EMIT_PER_PX;
    while(expected > 0){
      if(Math.random() < Math.min(1, expected)) spawnBubble(x,y);
      expected -= 1;
    }
  }
  function updateBubbles(dt){
    const now = U.now()/1000;
    for(let i=0;i<POOL_SIZE;i++){
      const b=bubbles[i]; if(!b.alive) continue;
      if(b.state===0){
        const age=now-b.born;
        if(age>=b.life){ b.state=1; b.popT=0; continue; }
        b.x+=b.vx*dt; b.y+=b.vy*dt; b.r*=(1+0.12*dt);
        b.alpha=Math.max(0, 0.9 - age*FADE);
      }else{
        b.popT+=dt; const t=b.popT/POP_TIME;
        if(t>=1){ b.alive=false; continue; }
        b.r*=(1+5.0*dt);
        b.alpha=Math.max(0, 0.6*(1 - t*1.2));
      }
    }
  }
  function drawBubbles(){
    const prev = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation='lighter';
    for(let i=0;i<POOL_SIZE;i++){
      const b=bubbles[i]; if(!b.alive||b.alpha<=0.01) continue;
      ctx.save(); ctx.globalAlpha=b.alpha;
      if(b.state===0){
        const grad = ctx.createRadialGradient(b.x - b.r*0.4, b.y - b.r*0.4, b.r*0.1, b.x, b.y, b.r);
        grad.addColorStop(0, 'rgba(255,255,255,0.35)');
        grad.addColorStop(0.7,'rgba(180,220,255,0.18)');
        grad.addColorStop(1, 'rgba(180,220,255,0.0)');
        ctx.fillStyle=grad;
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
        ctx.lineWidth=Math.max(1,b.r*0.12);
        ctx.strokeStyle='rgba(240,250,255,0.7)';
        ctx.stroke();
      }else{
        ctx.lineWidth=Math.max(1,b.r*0.08);
        ctx.strokeStyle='rgba(255,255,255,0.8)';
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.stroke();
      }
      ctx.restore();
    }
    ctx.globalCompositeOperation=prev;
  }

  // ===== 루프 =====
  function loop(now){
    if(!G.running) return;
    const dt=(now-G.lastFrame)/1000; G.lastFrame=now; G.elapsedMs=now-G.startMs;

    // 이전 위치 저장(거품 방출 기준)
    const prevPos = soapPos();

    if(!G.window.opened && now>=G.window.openAt) G.window.opened = true;
    // 경고 시작: 창문 열리기 5초 전
    if(!G.warned && now >= G.window.openAt - WARN_BEFORE_MS && now < G.window.openAt){
      G.warned = true; logEvent('NOTICE','창문이 곧 열립니다 (5초 전)');
    }
    trySpawnObstacle();
    G.t += CONFIG.speedNodesPerSec * dt;
    while(G.t>=1 && G.running){
      G.t -= 1;
      applyPendingTurnAtJunction();
      if(!stepToNextEdge()) break;
    }

    // 현재 위치와의 거리만큼 거품 방출
    const currPos = soapPos();
    const dist = Math.hypot(currPos.x - prevPos.x, currPos.y - prevPos.y);
    emitByDistance(dist, currPos.x, currPos.y);
    updateBubbles(dt);

    draw(); updateHUD();
    requestAnimationFrame(loop);
  }

  function updateHUD(){
    stageLabel.textContent = `${G.stageIndex+1} / 5`;
    timeLabel.textContent = U.fmtTime(G.elapsedMs);
    const remain = Math.max(0, G.window.openAt - (G.startMs + G.elapsedMs));
    windowLabel.textContent = G.window.opened ? '열림!' : `닫힘 (${U.fmtTime(remain)} 후 오픈)`;
  }

  // ===== 렌더링 =====
  function circle(x,y,r,fill){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=fill; ctx.fill(); }

  function draw(){
    const w=canvas.width, h=canvas.height;
    ctx.clearRect(0,0,w,h);
    drawGrid(); drawWindow(); drawWindowWarning(); drawObstacles(); drawSoap(); drawBubbles(); // 거품을 맨 위에
  }

  function drawGrid(){
    const usableW=canvas.width-G.margin*2, usableH=canvas.height-G.margin*2;
    const stepX=usableW/(G.gridNodes-1), stepY=usableH/(G.gridNodes-1);
    for(let ty=0; ty<G.gridTiles; ty++){
      for(let tx=0; tx<G.gridTiles; tx++){
        const x=G.margin+tx*stepX, y=G.margin+ty*stepY;
        ctx.fillStyle=((tx+ty)%2===0?'#0f1433':'#0d122d');
        ctx.fillRect(x,y,stepX,stepY);
      }
    }
    ctx.lineWidth=2; ctx.strokeStyle=varCSS('--grid','#2a315c');
    for(let i=0;i<G.gridNodes;i++){
      const x=G.margin+i*stepX, y=G.margin+i*stepY;
      ctx.beginPath(); ctx.moveTo(x,G.margin); ctx.lineTo(x,G.margin+usableH); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(G.margin,y); ctx.lineTo(G.margin+usableW,y); ctx.stroke();
    }
    ctx.lineWidth=4; ctx.strokeStyle=varCSS('--grid2','#3f4678');
    ctx.strokeRect(G.margin, G.margin, usableW, usableH);
  }
  function varCSS(name, fallback){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback; }

  function drawWindow(){
    const p=nodeToXY({x:G.window.x,y:G.window.y});
    ctx.save(); ctx.translate(p.x,p.y);
    let ax=0, ay=0; const max=G.gridNodes-1;
    if(G.window.side==='TOP') ay=-14; else if(G.window.side==='BOTTOM') ay=14;
    if(G.window.side==='LEFT') ax=-14; else if(G.window.side==='RIGHT') ax=14;
    const c = G.window.opened ? '#4dff88' : '#ffd166';
    circle(0,0,7,c);
    ctx.fillStyle=c; ctx.beginPath(); ctx.moveTo(ax,ay);
    ctx.lineTo(ax + (ay===0?0:-5), ay + (ax===0?0:-5));
    ctx.lineTo(ax + (ay===0?0: 5), ay + (ax===0?0: 5));
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  function drawObstacles(){
  function drawWindowWarning(){
    if(!G.running) return;
    const now = U.now();
    if(now < G.window.openAt - WARN_BEFORE_MS || now >= G.window.openAt) return;

    const remainMs = Math.max(0, G.window.openAt - now);
    const sec = Math.ceil(remainMs/1000);

    const p = nodeToXY({x:G.window.x, y:G.window.y});
    const border = 20; // distance outside the grid
    let bx = p.x, by = p.y, ax = 0, ay = 0;

    // place label just OUTSIDE the board so it doesn't cover lines
    if(G.window.side==='TOP'){ by = p.y - border; ay = -10; }
    else if(G.window.side==='BOTTOM'){ by = p.y + border; ay = 10; }
    else if(G.window.side==='LEFT'){ bx = p.x - border; ax = -10; }
    else if(G.window.side==='RIGHT'){ bx = p.x + border; ax = 10; }

    // badge style
    const label = `곧 열림 (${sec})`;
    ctx.save();
    ctx.translate(bx, by);

    // subtle pulse
    const t = (now%1000)/1000;
    const pulse = 0.9 + 0.1*Math.sin(t*2*Math.PI);

    // text metrics
    ctx.font = 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
    const padX = 8, padY = 6;
    const metrics = ctx.measureText(label);
    const w = metrics.width + padX*2;
    const h = 20 + padY*0;

    // background rounded rect
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(32, 38, 81, 0.9)';
    roundRect(ctx, -w/2, -h/2, w, h, 10);
    ctx.fill();

    // border glow
    ctx.strokeStyle = 'rgba(77, 255, 136, 0.9)';
    ctx.lineWidth = 2 * pulse;
    roundRect(ctx, -w/2, -h/2, w, h, 10);
    ctx.stroke();

    // text
    ctx.fillStyle = '#c9ffdf';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, 0, 0);

    // arrow toward window node
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(77, 255, 136, 0.9)';
    ctx.lineTo(-ax*2, -ay*2); // small tail
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-ax*2, -ay*2);
    ctx.lineTo(-ax*2 + Math.sign(ax||ay)*5, -ay*2 + 5*(ay?Math.sign(ay):0));
    ctx.lineTo(-ax*2 + Math.sign(ax||ay)*-5, -ay*2 + 5*(ay?Math.sign(ay):0));
    ctx.closePath();
    ctx.fillStyle = 'rgba(77, 255, 136, 0.9)';
    ctx.fill();

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    // no fill/stroke here; caller does it
  }

    const now=U.now();
    G.obstacles = G.obstacles.filter(o=>o.until>now);
    ctx.lineWidth=8;
    for(const o of G.obstacles){
      const a=nodeToXY(o.a), b=nodeToXY(o.b);
      const pulse=0.5+0.5*Math.sin(now/150);
      ctx.strokeStyle=`rgba(255,128,80,${0.6+0.3*pulse})`;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      const midX=(a.x+b.x)/2, midY=(a.y+b.y)/2; circle(midX,midY,6,'#ff8050');
    }
  }

  function drawSoap(){
    const pos=soapPos();
    ctx.save();
    const angle=[0,Math.PI/2,Math.PI,-Math.PI/2][G.dir];
    ctx.translate(pos.x,pos.y); ctx.rotate(angle);

    // 그림자
    ctx.globalAlpha=0.3; circle(10,10,9,'#000'); ctx.globalAlpha=1;

    // 비누: 직사각형(요청사항)
    const w=24, h=14;
    ctx.fillStyle='#9ee7ff'; ctx.strokeStyle='#62c7e8';
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.rect(-w/2, -h/2, w, h);
    ctx.fill(); ctx.stroke();

    // 하이라이트(살짝)
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.fillRect(-w*0.25, -h*0.25, w*0.2, h*0.18);

    ctx.restore();
  }

  // ===== 순위표 =====
  const LEADER_KEY='soap_escape_leaderboard_v1';
  function saveToLeaderboard(rec){
    const list=U.loadJSON(LEADER_KEY,[]);
    list.push(rec);
    list.sort((a,b)=>{ const ca=a.result==='CLEAR', cb=b.result==='CLEAR';
      if(ca!==cb) return cb-ca;
      if(ca) return a.timeMs - b.timeMs;
      return b.timeMs - a.timeMs;
    });
    U.saveJSON(LEADER_KEY, list.slice(0,100));
  }
  function renderLeaderboard(){
    const list=U.loadJSON(LEADER_KEY,[]);
    leaderboardBody.innerHTML='';
    list.forEach((r,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>${i+1}</td>
        <td>${escapeHtml(r.name)}</td>
        <td>${r.stage}</td>
        <td><span class="tag ${r.result==='CLEAR'?'':'fail'}">${r.result}</span></td>
        <td>${U.fmtTime(r.timeMs)}</td>
        <td>${U.fmtDate(r.ts)}</td>`;
      leaderboardBody.appendChild(tr);
    });
  }
  function escapeHtml(s){ return s.replace(/[&<>\"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\\\"":"&quot;","'":"&#39;"}[m])); }

  // ===== 시작/입력 바인딩 =====
  btnLeft.addEventListener('click', ()=>reserveTurn('L'));
  btnRight.addEventListener('click', ()=>reserveTurn('R'));
  btnStart.addEventListener('click', ()=>{
    if(G.running) endGame('fail','중지 버튼으로 게임을 종료했습니다.');
    else startGame();
  });
  window.addEventListener('keydown', (e)=>{
    if(e.key==='a'||e.key==='A'||e.key==='ArrowLeft') reserveTurn('L');
    else if(e.key==='d'||e.key==='D'||e.key==='ArrowRight') reserveTurn('R');
    else if(e.key===' '){ e.preventDefault(); if(!G.running) startGame(); }
  });

  // ===== 스타트 위치 & 창문 =====
  function pickRandomStart(){
    const max=G.gridNodes-1;
    while(true){
      const x=U.randInt(0,max), y=U.randInt(0,max); let dir=U.randInt(0,3);
      if((x===0&&dir===2)||(x===max&&dir===0)||(y===0&&dir===3)||(y===max&&dir===1)) dir=(dir+1)%4;
      const a={x,y}, d=DIRS[dir], b={x:x+d.x, y:y+d.y};
      if(b.x>=0 && b.x<=max && b.y>=0 && b.y<=max){ G.nodeA=a; G.nodeB=b; G.dir=dir; G.t=0; return; }
    }
  }
  function pickRandomWindow(){
    const choices=[]; const max=G.gridNodes-1;
    for(let i=1;i<=max-1;i++){
      choices.push({x:i,y:0,side:'TOP'},{x:i,y:max,side:'BOTTOM'},{x:0,y:i,side:'LEFT'},{x:max,y:i,side:'RIGHT'});
    }
    const w=choices[U.randInt(0,choices.length-1)];
    G.window = { ...w, openAt: G.startMs + CONFIG.windowOpenMs, opened:false };
  }

  // ===== 초기화 =====
  function init(){
    resizeCanvas();
    renderLeaderboard();
    draw(); updateHUD();
    btnStart.addEventListener('contextmenu', e=>{
      e.preventDefault();
      G.stageIndex = (G.stageIndex+1) % CONFIG.stages.length;
      stageLabel.textContent = `${G.stageIndex+1} / ${CONFIG.stages.length}`;
    });
  }
  init();
  </script>
</body>
</html>
